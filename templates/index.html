<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BuFlood Watch</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <video autoplay muted loop playsinline class="background-video">
        <source src="https://cdn.coverr.co/videos/grass-in-the-windy-weather-1578/1080p.mp4" type="video/mp4">
    </video>
    <div class="overlay"></div>

    <header class="hero">
        <div class="status-pill {{ 'flooding' if status.is_flooding else 'dry' }}">{{ status.status }}</div>
        <h1 class="headline">BU Flood Status</h1>
        <p class="status-message">{{ status.message }}</p>
        {% if status.level_label %}
            <p class="level">Consensus impact: <strong>{{ status.level_label }}</strong></p>
        {% endif %}
        <p class="reports">Live data from {{ report_count }} report{{ '' if report_count == 1 else 's' }}</p>
        {% if request.args.get('thanks') %}
            <p class="flash success">Thank you for submitting your report!</p>
        {% endif %}
    </header>

    <main class="content">
        <section class="panel">
            <h2>Share what you see</h2>
            <form action="{{ url_for('report') }}" method="post" class="report-form">
                <p id="cooldown-message" class="flash" style="display: none;"></p>
                <fieldset class="choice-group">
                    <div class="choice-buttons">
                        <input type="radio" id="status-flood" name="flooded" value="yes" required>
                        <label for="status-flood" class="btn label-btn flood">Flooding</label>
                        <input type="radio" id="status-clear" name="flooded" value="no" required>
                        <label for="status-clear" class="btn label-btn clear">Not flooded</label>
                    </div>
                </fieldset>

                <fieldset class="choice-group">
                    <legend class="field-label">Optional : </legend>
                    <div class="severity-options">
                        {% for value, option in level_options.items() %}
                            <input type="radio" id="impact-{{ value }}" name="level_category" value="{{ value }}">
                            <label for="impact-{{ value }}" class="severity-card">{{ option.label }}</label>
                        {% endfor %}
                    </div>
                </fieldset>
                <button type="submit" id="report-submit-proxy" hidden aria-hidden="true"></button>
            </form>
        </section>

        <section class="panel info">
            <h2>How it works</h2>
            <ul>
                <li>The dashboard starts in monitoring mode until we receive at least {{ MIN_REPORTS_FOR_STATUS }} community reports.</li>
                <li>When over 60% of reports indicate flooding and impact reports agree, the status flips to <strong>Flooding</strong>.</li>
                <li>The consensus impact (walkable, motorcycle can't pass, car can't pass) is displayed when neighbors agree.</li>
                <li>Stay safe and continue sharing updates with your neighbors.</li>
            </ul>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const COOLDOWN_SECONDS = 60;
            const COOKIE_NAME = 'reportCooldownUntil';
            const form = document.querySelector('.report-form');
            const floodStatusButtons = Array.from(document.querySelectorAll('input[name="flooded"]'));
            const labelButtons = Array.from(document.querySelectorAll('.label-btn'))
            const levelButtons = Array.from(document.querySelectorAll('input[name="level_category"]'));
            const cooldownMessage = document.getElementById('cooldown-message');
            const submitProxy = document.getElementById('report-submit-proxy');
            let cooldownIntervalId = null;

            console.log(labelButtons);
            

            if (!form || floodStatusButtons.length === 0) {
                return;
            }

            function readCookie(name) {
                return document.cookie
                    .split(';')
                    .map(part => part.trim())
                    .find(part => part.startsWith(name + '='))
                    ?.split('=')[1] || null;
            }

            function clearCooldownCookie() {
                document.cookie = COOKIE_NAME + '=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT';
            }

            function setCooldownCookie(expiresAt) {
                const maxAge = COOLDOWN_SECONDS + 5;
                document.cookie = COOKIE_NAME + '=' + expiresAt + '; path=/; max-age=' + maxAge + '; SameSite=Lax';
            }

            function getRemainingSeconds() {
                const cookieValue = readCookie(COOKIE_NAME);
                if (!cookieValue) {
                    return 0;
                }
                const expiresAt = parseInt(cookieValue, 10);
                if (Number.isNaN(expiresAt)) {
                    clearCooldownCookie();
                    return 0;
                }
                const remainingMs = expiresAt - Date.now();
                if (remainingMs <= 0) {
                    clearCooldownCookie();
                    return 0;
                }
                return Math.ceil(remainingMs / 1000);
            }

            function formatCooldown(remainingSeconds) {
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                return minutes + ':' + seconds.toString().padStart(2, '0');
            }

            function toggleInputs(disabled) {
                floodStatusButtons.forEach(button => {
                    button.disabled = disabled;
                });
                levelButtons.forEach(button => {
                    button.disabled = disabled;
                });
            }

            function updateCooldownMessage(remainingSeconds) {
                if (!cooldownMessage) {
                    return;
                }
                if (remainingSeconds > 0) {
                    cooldownMessage.style.display = 'block';
                    cooldownMessage.style.color = '#ffc107';
                    cooldownMessage.textContent = 'Thanks for the update! You can send another report in ' + formatCooldown(remainingSeconds) + '.';
                
                    labelButtons.forEach((btn) => {
                        btn.style.opacity = '.5'
                    })

                } else {
                    cooldownMessage.style.display = 'none';
                    cooldownMessage.textContent = '';

                    labelButtons.forEach((btn) => {
                        btn.style.opacity = '1'
                    })
                }
            }

            function refreshCooldownState() {
                const remainingSeconds = getRemainingSeconds();
                if (remainingSeconds > 0) {
                    toggleInputs(true);
                    updateCooldownMessage(remainingSeconds);
                    if (!cooldownIntervalId) {
                        cooldownIntervalId = setInterval(refreshCooldownState, 1000);
                    }
                } else {
                    toggleInputs(false);
                    updateCooldownMessage(0);
                    if (cooldownIntervalId) {
                        clearInterval(cooldownIntervalId);
                        cooldownIntervalId = null;
                    }
                }
            }

            function startCooldown() {
                const expiresAt = Date.now() + COOLDOWN_SECONDS * 1000;
                setCooldownCookie(expiresAt);
                if (cooldownIntervalId) {
                    clearInterval(cooldownIntervalId);
                    cooldownIntervalId = null;
                }
                setTimeout(refreshCooldownState, 0);
            }

            form.addEventListener('submit', function (event) {
                const remainingSeconds = getRemainingSeconds();
                if (remainingSeconds > 0) {
                    event.preventDefault();
                    refreshCooldownState();
                    floodStatusButtons.forEach(button => {
                        button.checked = false;
                    });
                    levelButtons.forEach(button => {
                        button.checked = false;
                    });
                    return;
                }
                startCooldown();
            });

            floodStatusButtons.forEach(button => {
                button.addEventListener('change', () => {
                    if (typeof form.requestSubmit === 'function') {
                        form.requestSubmit();
                    } else if (submitProxy) {
                        submitProxy.click();
                    } else {
                        form.submit();
                    }
                });
            });

            refreshCooldownState();
        });
    </script>
</body>
</html>
